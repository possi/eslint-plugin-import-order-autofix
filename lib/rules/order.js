'use strict';

var _os = require('os');

var _importType = require('../core/importType');

var _importType2 = _interopRequireDefault(_importType);

var _staticRequire = require('../core/staticRequire');

var _staticRequire2 = _interopRequireDefault(_staticRequire);

var _babelEslint = require('babel-eslint');

var _babelEslint2 = _interopRequireDefault(_babelEslint);

var _jscodeshift = require('jscodeshift');

var _jscodeshift2 = _interopRequireDefault(_jscodeshift);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

require('./../core/add-types');

const j = _jscodeshift2.default.withParser(_babelEslint2.default);

_jscodeshift2.default.types.Type.def('ExperimentalSpreadProperty').bases('Node');
_jscodeshift2.default.types.Type.def('ExperimentalRestProperty').bases('Node');

_jscodeshift2.default.types.finalize();

const defaultGroups = ['builtin', 'external', 'parent', 'sibling', 'index'];

// REPORTING

function reverse(array) {
  return array.map(function (v) {
    return {
      name: v.name,
      rank: -v.rank,
      node: v.node
    };
  }).reverse();
}

function findOutOfOrder(imported) {
  if (imported.length === 0) {
    return [];
  }
  let maxSeenRankNode = imported[0];
  return imported.filter(function (importedModule) {
    const res = importedModule.rank < maxSeenRankNode.rank;
    if (maxSeenRankNode.rank < importedModule.rank) {
      maxSeenRankNode = importedModule;
    }
    return res;
  });
}

function findRootNode(j, root, node) {
  let result = null;

  root.find(j.Node).filter(p => p.node === node).forEach(p => {
    let parent = p;

    while (parent.parent != null && parent.parent.value.body == null) {
      parent = parent.parent;
    }

    result = parent;
  });

  return result;
}

function fixOutOfOrder(context, firstNode, secondNode, order) {
  const sourceCode = context.getSourceCode();
  const root = j(sourceCode.ast);

  const firstRoot = findRootNode(j, root, firstNode.node);
  const secondRoot = findRootNode(j, root, secondNode.node);
  const newCode = sourceCode.getText(secondRoot.node);

  const msg = () => `\`${secondNode.name}\` import should occur ${order}` + ` import \`${firstNode.name}\``;

  if (order === 'before') {
    context.report({
      node: secondNode.node,
      message: msg(),
      fix: fixer => [fixer.insertTextBefore(firstRoot.node, newCode + "\n"), fixer.remove(secondRoot.node)]
    });
  } else if (order === 'after') {
    context.report({
      node: secondNode.node,
      message: msg(),
      fix: fixer => [fixer.insertTextAfter(firstRoot.node, "\n" + newCode), fixer.remove(secondRoot.node)]
    });
  }
}

function reportOutOfOrder(context, imported, outOfOrder, order) {
  outOfOrder.forEach(function (imp) {
    const found = imported.find(function hasHigherRank(importedItem) {
      return importedItem.rank > imp.rank;
    });
    fixOutOfOrder(context, found, imp, order);
  });
}

function makeOutOfOrderReport(context, imported) {
  const outOfOrder = findOutOfOrder(imported);
  if (!outOfOrder.length) {
    return;
  }
  // There are things to report. Try to minimize the number of reported errors.
  const reversedImported = reverse(imported);
  const reversedOrder = findOutOfOrder(reversedImported);
  if (reversedOrder.length < outOfOrder.length) {
    reportOutOfOrder(context, reversedImported, reversedOrder, 'after');
    return;
  }
  reportOutOfOrder(context, imported, outOfOrder, 'before');
}

// DETECTING

function computeRank(context, ranks, name, type) {
  return ranks[(0, _importType2.default)(name, context)] + (type === 'import' ? 0 : 100);
}

function registerNode(context, node, name, type, ranks, imported) {
  const rank = computeRank(context, ranks, name, type);
  if (rank !== -1) {
    imported.push({ name, rank, node });
  }
}

function isInVariableDeclarator(node) {
  return node && (node.type === 'VariableDeclarator' || isInVariableDeclarator(node.parent));
}

const types = ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'];

// Creates an object with type-rank pairs.
// Example: { index: 0, sibling: 1, parent: 1, external: 1, builtin: 2, internal: 2 }
// Will throw an error if it contains a type that does not exist, or has a duplicate
function convertGroupsToRanks(groups) {
  const rankObject = groups.reduce(function (res, group, index) {
    if (typeof group === 'string') {
      group = [group];
    }
    group.forEach(function (groupItem) {
      if (types.indexOf(groupItem) === -1) {
        throw new Error('Incorrect configuration of the rule: Unknown type `' + JSON.stringify(groupItem) + '`');
      }
      if (res[groupItem] !== undefined) {
        throw new Error('Incorrect configuration of the rule: `' + groupItem + '` is duplicated');
      }
      res[groupItem] = index;
    });
    return res;
  }, {});

  const omittedTypes = types.filter(function (type) {
    return rankObject[type] === undefined;
  });

  return omittedTypes.reduce(function (res, type) {
    res[type] = groups.length;
    return res;
  }, rankObject);
}

function fixNewLineAfterImport(context, previousImport) {
  const root = j(context.getSourceCode().ast);

  const prevRoot = findRootNode(j, root, previousImport.node);

  return fixer => fixer.insertTextAfter(prevRoot.node, _os.EOL);
}

function removeNewLineAfterImport(context, currentImport, previousImport) {
  const root = j(context.getSourceCode().ast);

  const prevRoot = findRootNode(j, root, previousImport.node);
  const currRoot = findRootNode(j, root, currentImport.node);

  return fixer => fixer.removeRange([prevRoot.node.range[1] + 1, currRoot.node.range[0]]);
}

function makeNewlinesBetweenReport(context, imported, newlinesBetweenImports) {
  const getNumberOfEmptyLinesBetween = (currentImport, previousImport) => {
    const linesBetweenImports = context.getSourceCode().lines.slice(previousImport.node.loc.end.line, currentImport.node.loc.start.line - 1);

    return linesBetweenImports.filter(line => !line.trim().length).length;
  };

  let previousImport = imported[0];

  imported.slice(1).forEach(function (currentImport) {
    const emptyLinesCount = getNumberOfEmptyLinesBetween(currentImport, previousImport);
    if (newlinesBetweenImports === 'always') {
      if (currentImport.rank !== previousImport.rank && emptyLinesCount === 0) {
        context.report({
          node: previousImport.node,
          message: 'There should be at least one empty line between import groups',
          fix: fixNewLineAfterImport(context, previousImport)
        });
      } else if (currentImport.rank === previousImport.rank && emptyLinesCount > 0) {
        context.report({
          node: previousImport.node,
          message: 'There should be no empty line within import group',
          fix: removeNewLineAfterImport(context, currentImport, previousImport)
        });
      }
    } else if (emptyLinesCount > 0) {
      context.report({
        node: previousImport.node,
        message: 'There should be no empty line between import groups',
        fix: removeNewLineAfterImport(context, currentImport, previousImport)
      });
    }

    previousImport = currentImport;
  });
}

module.exports = {
  meta: {
    docs: {},
    fixable: 'code',
    schema: [{
      type: 'object',
      properties: {
        groups: {
          type: 'array'
        },
        'newlines-between': {
          enum: ['ignore', 'always', 'never']
        }
      },
      additionalProperties: false
    }]
  },

  create: function importOrderRule(context) {
    const options = context.options[0] || {};
    const newlinesBetweenImports = options['newlines-between'] || 'ignore';
    let ranks;

    try {
      ranks = convertGroupsToRanks(options.groups || defaultGroups);
    } catch (error) {
      // Malformed configuration
      return {
        Program: function (node) {
          context.report(node, error.message);
        }
      };
    }
    let imported = [];
    let level = 0;

    function incrementLevel() {
      level++;
    }
    function decrementLevel() {
      level--;
    }

    return {
      ImportDeclaration: function handleImports(node) {
        if (node.specifiers.length) {
          // Ignoring unassigned imports
          const name = node.source.value;
          registerNode(context, node, name, 'import', ranks, imported);
        }
      },
      CallExpression: function handleRequires(node) {
        if (level !== 0 || !(0, _staticRequire2.default)(node) || !isInVariableDeclarator(node.parent)) {
          return;
        }
        const name = node.arguments[0].value;
        registerNode(context, node, name, 'require', ranks, imported);
      },
      'Program:exit': function reportAndReset() {
        makeOutOfOrderReport(context, imported);

        if (newlinesBetweenImports !== 'ignore') {
          makeNewlinesBetweenReport(context, imported, newlinesBetweenImports);
        }

        imported = [];
      },
      FunctionDeclaration: incrementLevel,
      FunctionExpression: incrementLevel,
      ArrowFunctionExpression: incrementLevel,
      BlockStatement: incrementLevel,
      ObjectExpression: incrementLevel,
      'FunctionDeclaration:exit': decrementLevel,
      'FunctionExpression:exit': decrementLevel,
      'ArrowFunctionExpression:exit': decrementLevel,
      'BlockStatement:exit': decrementLevel,
      'ObjectExpression:exit': decrementLevel
    };
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJ1bGVzL29yZGVyLmpzIl0sIm5hbWVzIjpbInJlcXVpcmUiLCJqIiwid2l0aFBhcnNlciIsInR5cGVzIiwiVHlwZSIsImRlZiIsImJhc2VzIiwiZmluYWxpemUiLCJkZWZhdWx0R3JvdXBzIiwicmV2ZXJzZSIsImFycmF5IiwibWFwIiwidiIsIm5hbWUiLCJyYW5rIiwibm9kZSIsImZpbmRPdXRPZk9yZGVyIiwiaW1wb3J0ZWQiLCJsZW5ndGgiLCJtYXhTZWVuUmFua05vZGUiLCJmaWx0ZXIiLCJpbXBvcnRlZE1vZHVsZSIsInJlcyIsImZpbmRSb290Tm9kZSIsInJvb3QiLCJyZXN1bHQiLCJmaW5kIiwiTm9kZSIsInAiLCJmb3JFYWNoIiwicGFyZW50IiwidmFsdWUiLCJib2R5IiwiZml4T3V0T2ZPcmRlciIsImNvbnRleHQiLCJmaXJzdE5vZGUiLCJzZWNvbmROb2RlIiwib3JkZXIiLCJzb3VyY2VDb2RlIiwiZ2V0U291cmNlQ29kZSIsImFzdCIsImZpcnN0Um9vdCIsInNlY29uZFJvb3QiLCJuZXdDb2RlIiwiZ2V0VGV4dCIsIm1zZyIsInJlcG9ydCIsIm1lc3NhZ2UiLCJmaXgiLCJmaXhlciIsImluc2VydFRleHRCZWZvcmUiLCJyZW1vdmUiLCJpbnNlcnRUZXh0QWZ0ZXIiLCJyZXBvcnRPdXRPZk9yZGVyIiwib3V0T2ZPcmRlciIsImltcCIsImZvdW5kIiwiaGFzSGlnaGVyUmFuayIsImltcG9ydGVkSXRlbSIsIm1ha2VPdXRPZk9yZGVyUmVwb3J0IiwicmV2ZXJzZWRJbXBvcnRlZCIsInJldmVyc2VkT3JkZXIiLCJjb21wdXRlUmFuayIsInJhbmtzIiwidHlwZSIsInJlZ2lzdGVyTm9kZSIsInB1c2giLCJpc0luVmFyaWFibGVEZWNsYXJhdG9yIiwiY29udmVydEdyb3Vwc1RvUmFua3MiLCJncm91cHMiLCJyYW5rT2JqZWN0IiwicmVkdWNlIiwiZ3JvdXAiLCJpbmRleCIsImdyb3VwSXRlbSIsImluZGV4T2YiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1bmRlZmluZWQiLCJvbWl0dGVkVHlwZXMiLCJmaXhOZXdMaW5lQWZ0ZXJJbXBvcnQiLCJwcmV2aW91c0ltcG9ydCIsInByZXZSb290IiwicmVtb3ZlTmV3TGluZUFmdGVySW1wb3J0IiwiY3VycmVudEltcG9ydCIsImN1cnJSb290IiwicmVtb3ZlUmFuZ2UiLCJyYW5nZSIsIm1ha2VOZXdsaW5lc0JldHdlZW5SZXBvcnQiLCJuZXdsaW5lc0JldHdlZW5JbXBvcnRzIiwiZ2V0TnVtYmVyT2ZFbXB0eUxpbmVzQmV0d2VlbiIsImxpbmVzQmV0d2VlbkltcG9ydHMiLCJsaW5lcyIsInNsaWNlIiwibG9jIiwiZW5kIiwibGluZSIsInN0YXJ0IiwidHJpbSIsImVtcHR5TGluZXNDb3VudCIsIm1vZHVsZSIsImV4cG9ydHMiLCJtZXRhIiwiZG9jcyIsImZpeGFibGUiLCJzY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZW51bSIsImFkZGl0aW9uYWxQcm9wZXJ0aWVzIiwiY3JlYXRlIiwiaW1wb3J0T3JkZXJSdWxlIiwib3B0aW9ucyIsImVycm9yIiwiUHJvZ3JhbSIsImxldmVsIiwiaW5jcmVtZW50TGV2ZWwiLCJkZWNyZW1lbnRMZXZlbCIsIkltcG9ydERlY2xhcmF0aW9uIiwiaGFuZGxlSW1wb3J0cyIsInNwZWNpZmllcnMiLCJzb3VyY2UiLCJDYWxsRXhwcmVzc2lvbiIsImhhbmRsZVJlcXVpcmVzIiwiYXJndW1lbnRzIiwicmVwb3J0QW5kUmVzZXQiLCJGdW5jdGlvbkRlY2xhcmF0aW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iLCJCbG9ja1N0YXRlbWVudCIsIk9iamVjdEV4cHJlc3Npb24iXSwibWFwcGluZ3MiOiJBQUFBOztBQUlBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFQQUEsUUFBUSxxQkFBUjs7QUFRQSxNQUFNQyxJQUFJLHNCQUFZQyxVQUFaLHVCQUFWOztBQUVBLHNCQUFZQyxLQUFaLENBQWtCQyxJQUFsQixDQUF1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QyxRQUFsQyxFQUE0Q2tELEtBQTVDLEVBQW1EOUMsUUFBbkQ7QUFDRDtBQUNGLE9BTkk7QUFPTHlHLHNCQUFnQixTQUFTQyxjQUFULENBQXdCNUcsSUFBeEIsRUFBOEI7QUFDNUMsWUFBSW9HLFVBQVUsQ0FBVixJQUFlLENBQUMsNkJBQWdCcEcsSUFBaEIsQ0FBaEIsSUFBeUMsQ0FBQ29ELHVCQUF1QnBELEtBQUtlLE1BQTVCLENBQTlDLEVBQW1GO0FBQ2pGO0FBQ0Q7QUFDRCxjQUFNakIsT0FBT0UsS0FBSzZHLFNBQUwsQ0FBZSxDQUFmLEVBQWtCN0YsS0FBL0I7QUFDQWtDLHFCQUFhL0IsT0FBYixFQUFzQm5CLElBQXRCLEVBQTRCRixJQUE1QixFQUFrQyxTQUFsQyxFQUE2Q2tELEtBQTdDLEVBQW9EOUMsUUFBcEQ7QUFDRCxPQWJJO0FBY0wsc0JBQWdCLFNBQVM0RyxjQUFULEdBQTBCO0FBQ3hDbEUsNkJBQXFCekIsT0FBckIsRUFBOEJqQixRQUE5Qjs7QUFFQSxZQUFJeUUsMkJBQTJCLFFBQS9CLEVBQXlDO0FBQ3ZDRCxvQ0FBMEJ2RCxPQUExQixFQUFtQ2pCLFFBQW5DLEVBQTZDeUUsc0JBQTdDO0FBQ0Q7O0FBRUR6RSxtQkFBVyxFQUFYO0FBQ0QsT0F0Qkk7QUF1Qkw2RywyQkFBcUJWLGNBdkJoQjtBQXdCTFcsMEJBQW9CWCxjQXhCZjtBQXlCTFksK0JBQXlCWixjQXpCcEI7QUEwQkxhLHNCQUFnQmIsY0ExQlg7QUEyQkxjLHdCQUFrQmQsY0EzQmI7QUE0Qkwsa0NBQTRCQyxjQTVCdkI7QUE2QkwsaUNBQTJCQSxjQTdCdEI7QUE4Qkwsc0NBQWdDQSxjQTlCM0I7QUErQkwsNkJBQXVCQSxjQS9CbEI7QUFnQ0wsK0JBQXlCQTtBQWhDcEIsS0FBUDtBQWtDRDtBQS9FYyxDQUFqQiIsImZpbGUiOiJydWxlcy9vcmRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5yZXF1aXJlKCcuLy4uL2NvcmUvYWRkLXR5cGVzJyk7XG5cbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcbmltcG9ydCBpbXBvcnRUeXBlIGZyb20gJy4uL2NvcmUvaW1wb3J0VHlwZSdcbmltcG9ydCBpc1N0YXRpY1JlcXVpcmUgZnJvbSAnLi4vY29yZS9zdGF0aWNSZXF1aXJlJ1xuaW1wb3J0IHBhcnNlciBmcm9tICdiYWJlbC1lc2xpbnQnO1xuXG5pbXBvcnQganNjb2Rlc2hpZnQgZnJvbSAnanNjb2Rlc2hpZnQnO1xuY29uc3QgaiA9IGpzY29kZXNoaWZ0LndpdGhQYXJzZXIocGFyc2VyKTtcblxuanNjb2Rlc2hpZnQudHlwZXMuVHlwZS5kZWYoJ0V4cGVyaW1lbnRhbFNwcmVhZFByb3BlcnR5JykuYmFzZXMoJ05vZGUnKTtcbmpzY29kZXNoaWZ0LnR5cGVzLlR5cGUuZGVmKCdFeHBlcmltZW50YWxSZXN0UHJvcGVydHknKS5iYXNlcygnTm9kZScpO1xuXG5qc2NvZGVzaGlmdC50eXBlcy5maW5hbGl6ZSgpO1xuXG5jb25zdCBkZWZhdWx0R3JvdXBzID0gWydidWlsdGluJywgJ2V4dGVybmFsJywgJ3BhcmVudCcsICdzaWJsaW5nJywgJ2luZGV4J11cblxuLy8gUkVQT1JUSU5HXG5cbmZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB2Lm5hbWUsXG4gICAgICByYW5rOiAtdi5yYW5rLFxuICAgICAgbm9kZTogdi5ub2RlLFxuICAgIH1cbiAgfSkucmV2ZXJzZSgpXG59XG5cbmZ1bmN0aW9uIGZpbmRPdXRPZk9yZGVyKGltcG9ydGVkKSB7XG4gIGlmIChpbXBvcnRlZC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICBsZXQgbWF4U2VlblJhbmtOb2RlID0gaW1wb3J0ZWRbMF1cbiAgcmV0dXJuIGltcG9ydGVkLmZpbHRlcihmdW5jdGlvbiAoaW1wb3J0ZWRNb2R1bGUpIHtcbiAgICBjb25zdCByZXMgPSBpbXBvcnRlZE1vZHVsZS5yYW5rIDwgbWF4U2VlblJhbmtOb2RlLnJhbmtcbiAgICBpZiAobWF4U2VlblJhbmtOb2RlLnJhbmsgPCBpbXBvcnRlZE1vZHVsZS5yYW5rKSB7XG4gICAgICBtYXhTZWVuUmFua05vZGUgPSBpbXBvcnRlZE1vZHVsZVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cblxuZnVuY3Rpb24gZmluZFJvb3ROb2RlKGosIHJvb3QsIG5vZGUpIHtcbiAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgcm9vdFxuICAgIC5maW5kKGouTm9kZSlcbiAgICAuZmlsdGVyKChwKSA9PiBwLm5vZGUgPT09IG5vZGUpLmZvckVhY2gocCA9PiB7XG4gICAgbGV0IHBhcmVudCA9IHA7XG5cbiAgICB3aGlsZSAocGFyZW50LnBhcmVudCAhPSBudWxsICYmIHBhcmVudC5wYXJlbnQudmFsdWUuYm9keSA9PSBudWxsKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHBhcmVudDtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZml4T3V0T2ZPcmRlcihjb250ZXh0LCBmaXJzdE5vZGUsIHNlY29uZE5vZGUsIG9yZGVyKSB7XG4gIGNvbnN0IHNvdXJjZUNvZGUgPSBjb250ZXh0LmdldFNvdXJjZUNvZGUoKTtcbiAgY29uc3Qgcm9vdCA9IGooc291cmNlQ29kZS5hc3QpO1xuXG4gIGNvbnN0IGZpcnN0Um9vdCA9IGZpbmRSb290Tm9kZShqLCByb290LCBmaXJzdE5vZGUubm9kZSk7XG4gIGNvbnN0IHNlY29uZFJvb3QgPSBmaW5kUm9vdE5vZGUoaiwgcm9vdCwgc2Vjb25kTm9kZS5ub2RlKTtcbiAgY29uc3QgbmV3Q29kZSA9IHNvdXJjZUNvZGUuZ2V0VGV4dChzZWNvbmRSb290Lm5vZGUpO1xuXG4gIGNvbnN0IG1zZyA9ICgpID0+IGBcXGAke3NlY29uZE5vZGUubmFtZX1cXGAgaW1wb3J0IHNob3VsZCBvY2N1ciAke29yZGVyfWAgK1xuICAgIGAgaW1wb3J0IFxcYCR7Zmlyc3ROb2RlLm5hbWV9XFxgYDtcblxuICBpZiAob3JkZXIgPT09ICdiZWZvcmUnKSB7XG4gICAgY29udGV4dC5yZXBvcnQoe1xuICAgICAgbm9kZTogc2Vjb25kTm9kZS5ub2RlLFxuICAgICAgbWVzc2FnZTogbXNnKCksXG4gICAgICBmaXg6IGZpeGVyID0+IFtmaXhlci5pbnNlcnRUZXh0QmVmb3JlKGZpcnN0Um9vdC5ub2RlLCBuZXdDb2RlICsgXCJcXG5cIiksIGZpeGVyLnJlbW92ZShzZWNvbmRSb290Lm5vZGUpXVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9yZGVyID09PSAnYWZ0ZXInKSB7XG4gICAgY29udGV4dC5yZXBvcnQoe1xuICAgICAgbm9kZTogc2Vjb25kTm9kZS5ub2RlLFxuICAgICAgbWVzc2FnZTogbXNnKCksXG4gICAgICBmaXg6IGZpeGVyID0+IFtmaXhlci5pbnNlcnRUZXh0QWZ0ZXIoZmlyc3RSb290Lm5vZGUsIFwiXFxuXCIgKyBuZXdDb2RlKSwgZml4ZXIucmVtb3ZlKHNlY29uZFJvb3Qubm9kZSldXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwb3J0T3V0T2ZPcmRlcihjb250ZXh0LCBpbXBvcnRlZCwgb3V0T2ZPcmRlciwgb3JkZXIpIHtcbiAgb3V0T2ZPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChpbXApIHtcbiAgICBjb25zdCBmb3VuZCA9IGltcG9ydGVkLmZpbmQoZnVuY3Rpb24gaGFzSGlnaGVyUmFuayhpbXBvcnRlZEl0ZW0pIHtcbiAgICAgIHJldHVybiBpbXBvcnRlZEl0ZW0ucmFuayA+IGltcC5yYW5rXG4gICAgfSlcbiAgICBmaXhPdXRPZk9yZGVyKGNvbnRleHQsIGZvdW5kLCBpbXAsIG9yZGVyKTtcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZU91dE9mT3JkZXJSZXBvcnQoY29udGV4dCwgaW1wb3J0ZWQpIHtcbiAgY29uc3Qgb3V0T2ZPcmRlciA9IGZpbmRPdXRPZk9yZGVyKGltcG9ydGVkKVxuICBpZiAoIW91dE9mT3JkZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gVGhlcmUgYXJlIHRoaW5ncyB0byByZXBvcnQuIFRyeSB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIHJlcG9ydGVkIGVycm9ycy5cbiAgY29uc3QgcmV2ZXJzZWRJbXBvcnRlZCA9IHJldmVyc2UoaW1wb3J0ZWQpXG4gIGNvbnN0IHJldmVyc2VkT3JkZXIgPSBmaW5kT3V0T2ZPcmRlcihyZXZlcnNlZEltcG9ydGVkKVxuICBpZiAocmV2ZXJzZWRPcmRlci5sZW5ndGggPCBvdXRPZk9yZGVyLmxlbmd0aCkge1xuICAgIHJlcG9ydE91dE9mT3JkZXIoY29udGV4dCwgcmV2ZXJzZWRJbXBvcnRlZCwgcmV2ZXJzZWRPcmRlciwgJ2FmdGVyJylcbiAgICByZXR1cm5cbiAgfVxuICByZXBvcnRPdXRPZk9yZGVyKGNvbnRleHQsIGltcG9ydGVkLCBvdXRPZk9yZGVyLCAnYmVmb3JlJylcbn1cblxuLy8gREVURUNUSU5HXG5cbmZ1bmN0aW9uIGNvbXB1dGVSYW5rKGNvbnRleHQsIHJhbmtzLCBuYW1lLCB0eXBlKSB7XG4gIHJldHVybiByYW5rc1tpbXBvcnRUeXBlKG5hbWUsIGNvbnRleHQpXSArXG4gICAgKHR5cGUgPT09ICdpbXBvcnQnID8gMCA6IDEwMClcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJOb2RlKGNvbnRleHQsIG5vZGUsIG5hbWUsIHR5cGUsIHJhbmtzLCBpbXBvcnRlZCkge1xuICBjb25zdCByYW5rID0gY29tcHV0ZVJhbmsoY29udGV4dCwgcmFua3MsIG5hbWUsIHR5cGUpXG4gIGlmIChyYW5rICE9PSAtMSkge1xuICAgIGltcG9ydGVkLnB1c2goe25hbWUsIHJhbmssIG5vZGV9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5WYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJlxuICAgIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0b3InIHx8IGlzSW5WYXJpYWJsZURlY2xhcmF0b3Iobm9kZS5wYXJlbnQpKVxufVxuXG5jb25zdCB0eXBlcyA9IFsnYnVpbHRpbicsICdleHRlcm5hbCcsICdpbnRlcm5hbCcsICdwYXJlbnQnLCAnc2libGluZycsICdpbmRleCddXG5cbi8vIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdHlwZS1yYW5rIHBhaXJzLlxuLy8gRXhhbXBsZTogeyBpbmRleDogMCwgc2libGluZzogMSwgcGFyZW50OiAxLCBleHRlcm5hbDogMSwgYnVpbHRpbjogMiwgaW50ZXJuYWw6IDIgfVxuLy8gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBpdCBjb250YWlucyBhIHR5cGUgdGhhdCBkb2VzIG5vdCBleGlzdCwgb3IgaGFzIGEgZHVwbGljYXRlXG5mdW5jdGlvbiBjb252ZXJ0R3JvdXBzVG9SYW5rcyhncm91cHMpIHtcbiAgY29uc3QgcmFua09iamVjdCA9IGdyb3Vwcy5yZWR1Y2UoZnVuY3Rpb24ocmVzLCBncm91cCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIGdyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgZ3JvdXAgPSBbZ3JvdXBdXG4gICAgfVxuICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBJdGVtKSB7XG4gICAgICBpZiAodHlwZXMuaW5kZXhPZihncm91cEl0ZW0pID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBjb25maWd1cmF0aW9uIG9mIHRoZSBydWxlOiBVbmtub3duIHR5cGUgYCcgK1xuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGdyb3VwSXRlbSkgKyAnYCcpXG4gICAgICB9XG4gICAgICBpZiAocmVzW2dyb3VwSXRlbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBjb25maWd1cmF0aW9uIG9mIHRoZSBydWxlOiBgJyArIGdyb3VwSXRlbSArICdgIGlzIGR1cGxpY2F0ZWQnKVxuICAgICAgfVxuICAgICAgcmVzW2dyb3VwSXRlbV0gPSBpbmRleFxuICAgIH0pXG4gICAgcmV0dXJuIHJlc1xuICB9LCB7fSlcblxuICBjb25zdCBvbWl0dGVkVHlwZXMgPSB0eXBlcy5maWx0ZXIoZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiByYW5rT2JqZWN0W3R5cGVdID09PSB1bmRlZmluZWRcbiAgfSlcblxuICByZXR1cm4gb21pdHRlZFR5cGVzLnJlZHVjZShmdW5jdGlvbihyZXMsIHR5cGUpIHtcbiAgICByZXNbdHlwZV0gPSBncm91cHMubGVuZ3RoXG4gICAgcmV0dXJuIHJlc1xuICB9LCByYW5rT2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmaXhOZXdMaW5lQWZ0ZXJJbXBvcnQoY29udGV4dCwgcHJldmlvdXNJbXBvcnQpIHtcbiAgY29uc3Qgcm9vdCA9IGooY29udGV4dC5nZXRTb3VyY2VDb2RlKCkuYXN0KTtcblxuICBjb25zdCBwcmV2Um9vdCA9IGZpbmRSb290Tm9kZShqLCByb290LCBwcmV2aW91c0ltcG9ydC5ub2RlKTtcblxuICByZXR1cm4gKGZpeGVyKSA9PiBmaXhlci5pbnNlcnRUZXh0QWZ0ZXIocHJldlJvb3Qubm9kZSwgRU9MKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTmV3TGluZUFmdGVySW1wb3J0KGNvbnRleHQsIGN1cnJlbnRJbXBvcnQsIHByZXZpb3VzSW1wb3J0KSB7XG4gIGNvbnN0IHJvb3QgPSBqKGNvbnRleHQuZ2V0U291cmNlQ29kZSgpLmFzdCk7XG5cbiAgY29uc3QgcHJldlJvb3QgPSBmaW5kUm9vdE5vZGUoaiwgcm9vdCwgcHJldmlvdXNJbXBvcnQubm9kZSk7XG4gIGNvbnN0IGN1cnJSb290ID0gZmluZFJvb3ROb2RlKGosIHJvb3QsIGN1cnJlbnRJbXBvcnQubm9kZSk7XG5cbiAgcmV0dXJuIChmaXhlcikgPT4gZml4ZXIucmVtb3ZlUmFuZ2UoW3ByZXZSb290Lm5vZGUucmFuZ2VbMV0gKyAxLCBjdXJyUm9vdC5ub2RlLnJhbmdlWzBdXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOZXdsaW5lc0JldHdlZW5SZXBvcnQgKGNvbnRleHQsIGltcG9ydGVkLCBuZXdsaW5lc0JldHdlZW5JbXBvcnRzKSB7XG4gIGNvbnN0IGdldE51bWJlck9mRW1wdHlMaW5lc0JldHdlZW4gPSAoY3VycmVudEltcG9ydCwgcHJldmlvdXNJbXBvcnQpID0+IHtcbiAgICBjb25zdCBsaW5lc0JldHdlZW5JbXBvcnRzID0gY29udGV4dC5nZXRTb3VyY2VDb2RlKCkubGluZXMuc2xpY2UoXG4gICAgICBwcmV2aW91c0ltcG9ydC5ub2RlLmxvYy5lbmQubGluZSxcbiAgICAgIGN1cnJlbnRJbXBvcnQubm9kZS5sb2Muc3RhcnQubGluZSAtIDFcbiAgICApXG5cbiAgICByZXR1cm4gbGluZXNCZXR3ZWVuSW1wb3J0cy5maWx0ZXIoKGxpbmUpID0+ICFsaW5lLnRyaW0oKS5sZW5ndGgpLmxlbmd0aFxuICB9XG5cbiAgbGV0IHByZXZpb3VzSW1wb3J0ID0gaW1wb3J0ZWRbMF1cblxuICBpbXBvcnRlZC5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uKGN1cnJlbnRJbXBvcnQpIHtcbiAgICBjb25zdCBlbXB0eUxpbmVzQ291bnQgPSBnZXROdW1iZXJPZkVtcHR5TGluZXNCZXR3ZWVuKGN1cnJlbnRJbXBvcnQsIHByZXZpb3VzSW1wb3J0KTtcbiAgICBpZiAobmV3bGluZXNCZXR3ZWVuSW1wb3J0cyA9PT0gJ2Fsd2F5cycpIHtcbiAgICAgIGlmIChjdXJyZW50SW1wb3J0LnJhbmsgIT09IHByZXZpb3VzSW1wb3J0LnJhbmsgJiYgZW1wdHlMaW5lc0NvdW50ID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICBub2RlOiBwcmV2aW91c0ltcG9ydC5ub2RlLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGVyZSBzaG91bGQgYmUgYXQgbGVhc3Qgb25lIGVtcHR5IGxpbmUgYmV0d2VlbiBpbXBvcnQgZ3JvdXBzJyxcbiAgICAgICAgICBmaXg6IGZpeE5ld0xpbmVBZnRlckltcG9ydChjb250ZXh0LCBwcmV2aW91c0ltcG9ydClcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRJbXBvcnQucmFuayA9PT0gcHJldmlvdXNJbXBvcnQucmFuayAmJiBlbXB0eUxpbmVzQ291bnQgPiAwKSB7XG4gICAgICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgICAgICBub2RlOiBwcmV2aW91c0ltcG9ydC5ub2RlLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGVyZSBzaG91bGQgYmUgbm8gZW1wdHkgbGluZSB3aXRoaW4gaW1wb3J0IGdyb3VwJyxcbiAgICAgICAgICBmaXg6IHJlbW92ZU5ld0xpbmVBZnRlckltcG9ydChjb250ZXh0LCBjdXJyZW50SW1wb3J0LCBwcmV2aW91c0ltcG9ydClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUxpbmVzQ291bnQgPiAwKSB7XG4gICAgICBjb250ZXh0LnJlcG9ydCh7XG4gICAgICAgIG5vZGU6IHByZXZpb3VzSW1wb3J0Lm5vZGUsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGVyZSBzaG91bGQgYmUgbm8gZW1wdHkgbGluZSBiZXR3ZWVuIGltcG9ydCBncm91cHMnLFxuICAgICAgICBmaXg6IHJlbW92ZU5ld0xpbmVBZnRlckltcG9ydChjb250ZXh0LCBjdXJyZW50SW1wb3J0LCBwcmV2aW91c0ltcG9ydClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByZXZpb3VzSW1wb3J0ID0gY3VycmVudEltcG9ydFxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWV0YToge1xuICAgIGRvY3M6IHt9LFxuICAgIGZpeGFibGU6ICdjb2RlJyxcbiAgICBzY2hlbWE6IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBncm91cHM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnbmV3bGluZXMtYmV0d2Vlbic6IHtcbiAgICAgICAgICAgIGVudW06IFsgJ2lnbm9yZScsICdhbHdheXMnLCAnbmV2ZXInIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgICAgfSxcbiAgICBdLFxuICB9LFxuXG4gIGNyZWF0ZTogZnVuY3Rpb24gaW1wb3J0T3JkZXJSdWxlIChjb250ZXh0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9uc1swXSB8fCB7fVxuICAgIGNvbnN0IG5ld2xpbmVzQmV0d2VlbkltcG9ydHMgPSBvcHRpb25zWyduZXdsaW5lcy1iZXR3ZWVuJ10gfHwgJ2lnbm9yZSdcbiAgICBsZXQgcmFua3NcblxuICAgIHRyeSB7XG4gICAgICByYW5rcyA9IGNvbnZlcnRHcm91cHNUb1JhbmtzKG9wdGlvbnMuZ3JvdXBzIHx8IGRlZmF1bHRHcm91cHMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE1hbGZvcm1lZCBjb25maWd1cmF0aW9uXG4gICAgICByZXR1cm4ge1xuICAgICAgICBQcm9ncmFtOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgY29udGV4dC5yZXBvcnQobm9kZSwgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGltcG9ydGVkID0gW11cbiAgICBsZXQgbGV2ZWwgPSAwXG5cbiAgICBmdW5jdGlvbiBpbmNyZW1lbnRMZXZlbCgpIHtcbiAgICAgIGxldmVsKytcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjcmVtZW50TGV2ZWwoKSB7XG4gICAgICBsZXZlbC0tXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIEltcG9ydERlY2xhcmF0aW9uOiBmdW5jdGlvbiBoYW5kbGVJbXBvcnRzKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHsgLy8gSWdub3JpbmcgdW5hc3NpZ25lZCBpbXBvcnRzXG4gICAgICAgICAgY29uc3QgbmFtZSA9IG5vZGUuc291cmNlLnZhbHVlXG4gICAgICAgICAgcmVnaXN0ZXJOb2RlKGNvbnRleHQsIG5vZGUsIG5hbWUsICdpbXBvcnQnLCByYW5rcywgaW1wb3J0ZWQpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gaGFuZGxlUmVxdWlyZXMobm9kZSkge1xuICAgICAgICBpZiAobGV2ZWwgIT09IDAgfHwgIWlzU3RhdGljUmVxdWlyZShub2RlKSB8fCAhaXNJblZhcmlhYmxlRGVjbGFyYXRvcihub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gbm9kZS5hcmd1bWVudHNbMF0udmFsdWVcbiAgICAgICAgcmVnaXN0ZXJOb2RlKGNvbnRleHQsIG5vZGUsIG5hbWUsICdyZXF1aXJlJywgcmFua3MsIGltcG9ydGVkKVxuICAgICAgfSxcbiAgICAgICdQcm9ncmFtOmV4aXQnOiBmdW5jdGlvbiByZXBvcnRBbmRSZXNldCgpIHtcbiAgICAgICAgbWFrZU91dE9mT3JkZXJSZXBvcnQoY29udGV4dCwgaW1wb3J0ZWQpXG5cbiAgICAgICAgaWYgKG5ld2xpbmVzQmV0d2VlbkltcG9ydHMgIT09ICdpZ25vcmUnKSB7XG4gICAgICAgICAgbWFrZU5ld2xpbmVzQmV0d2VlblJlcG9ydChjb250ZXh0LCBpbXBvcnRlZCwgbmV3bGluZXNCZXR3ZWVuSW1wb3J0cylcbiAgICAgICAgfVxuXG4gICAgICAgIGltcG9ydGVkID0gW11cbiAgICAgIH0sXG4gICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBpbmNyZW1lbnRMZXZlbCxcbiAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogaW5jcmVtZW50TGV2ZWwsXG4gICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogaW5jcmVtZW50TGV2ZWwsXG4gICAgICBCbG9ja1N0YXRlbWVudDogaW5jcmVtZW50TGV2ZWwsXG4gICAgICBPYmplY3RFeHByZXNzaW9uOiBpbmNyZW1lbnRMZXZlbCxcbiAgICAgICdGdW5jdGlvbkRlY2xhcmF0aW9uOmV4aXQnOiBkZWNyZW1lbnRMZXZlbCxcbiAgICAgICdGdW5jdGlvbkV4cHJlc3Npb246ZXhpdCc6IGRlY3JlbWVudExldmVsLFxuICAgICAgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uOmV4aXQnOiBkZWNyZW1lbnRMZXZlbCxcbiAgICAgICdCbG9ja1N0YXRlbWVudDpleGl0JzogZGVjcmVtZW50TGV2ZWwsXG4gICAgICAnT2JqZWN0RXhwcmVzc2lvbjpleGl0JzogZGVjcmVtZW50TGV2ZWwsXG4gICAgfVxuICB9LFxufVxuIl19